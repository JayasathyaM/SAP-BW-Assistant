"""
SAP BW Query Validator

This module provides comprehensive validation for SQL queries generated by the AI
to ensure they are safe, correct, and appropriate for SAP BW process chains.
"""

import re
import logging
from typing import Dict, List, Optional, Any, Set, Tuple
from enum import Enum

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SecurityLevel(Enum):
    """Security levels for query validation"""
    STRICT = "strict"      # Only SELECT queries on approved tables/views
    MODERATE = "moderate"  # SELECT queries with some joins and functions
    PERMISSIVE = "permissive"  # Most SELECT operations allowed

class ValidationResult:
    """Result of SQL query validation"""
    
    def __init__(self):
        self.is_valid: bool = True
        self.security_level: SecurityLevel = SecurityLevel.STRICT
        self.errors: List[str] = []
        self.warnings: List[str] = []
        self.suggestions: List[str] = []
        self.risk_score: float = 0.0  # 0.0 = safe, 1.0 = dangerous
        self.allowed_tables: Set[str] = set()
        self.blocked_operations: List[str] = []
        self.performance_warnings: List[str] = []
    
    def add_error(self, message: str):
        """Add an error message"""
        self.errors.append(message)
        self.is_valid = False
    
    def add_warning(self, message: str):
        """Add a warning message"""
        self.warnings.append(message)
    
    def add_suggestion(self, message: str):
        """Add a suggestion"""
        self.suggestions.append(message)
    
    def increase_risk(self, amount: float, reason: str):
        """Increase risk score"""
        self.risk_score = min(1.0, self.risk_score + amount)
        if amount > 0.3:  # Significant risk
            self.add_warning(f"Security risk: {reason}")

class QueryValidator:
    """
    Comprehensive SQL query validator for SAP BW process chains
    """
    
    # Approved SAP BW tables and views
    APPROVED_TABLES = {
        # Core tables
        'rspcchain', 'rspclogchain', 'rspcprocesslog', 'rspcvariant',
        # Optimized views
        'vw_latest_chain_runs', 'vw_chain_summary', 'vw_todays_activity'
    }
    
    # Dangerous SQL keywords that should be blocked
    DANGEROUS_KEYWORDS = {
        'delete', 'drop', 'truncate', 'alter', 'create', 'insert', 'update',
        'grant', 'revoke', 'exec', 'execute', 'xp_', 'sp_', 'bulk',
        'openrowset', 'opendatasource', 'into outfile', 'load_file'
    }
    
    # Risky functions that increase security risk
    RISKY_FUNCTIONS = {
        'concat_ws', 'load_file', 'into dumpfile', 'union', 'information_schema',
        'pg_sleep', 'benchmark', 'waitfor', 'dbms_lock'
    }
    
    # Approved SQL functions for SAP BW analysis
    APPROVED_FUNCTIONS = {
        'count', 'sum', 'avg', 'max', 'min', 'round', 'upper', 'lower',
        'substring', 'length', 'coalesce', 'case', 'cast', 'extract',
        'date_trunc', 'now', 'current_date', 'current_timestamp'
    }
    
    def __init__(self, security_level: SecurityLevel = SecurityLevel.STRICT):
        """
        Initialize the query validator
        
        Args:
            security_level: Security level for validation
        """
        self.security_level = security_level
        logger.info(f"QueryValidator initialized with security level: {security_level.value}")
    
    def validate_query(self, sql: str, context: Optional[str] = None) -> ValidationResult:
        """
        Validate a SQL query comprehensively
        
        Args:
            sql: SQL query to validate
            context: Optional context about the query
            
        Returns:
            ValidationResult with detailed validation information
        """
        result = ValidationResult()
        result.security_level = self.security_level
        
        if not sql or not sql.strip():
            result.add_error("Empty or null SQL query")
            return result
        
        # Normalize SQL for analysis
        sql_normalized = self._normalize_sql(sql)
        
        # Run validation checks
        self._validate_basic_structure(sql_normalized, result)
        self._validate_security(sql_normalized, result)
        self._validate_tables_and_views(sql_normalized, result)
        self._validate_functions(sql_normalized, result)
        self._validate_performance(sql_normalized, result)
        self._validate_sap_bw_specific(sql_normalized, result)
        
        # Calculate final risk score
        if result.errors:
            result.risk_score = 1.0
        elif result.risk_score > 0.7:
            result.add_warning("High risk query detected")
        
        logger.info(f"Query validation completed. Valid: {result.is_valid}, Risk: {result.risk_score:.2f}")
        return result
    
    def is_safe_sql(self, sql: str) -> bool:
        """
        Simple safety check for SQL queries (backward compatibility)
        
        Args:
            sql: SQL query to validate
            
        Returns:
            True if query is safe, False otherwise
        """
        try:
            result = self.validate_query(sql)
            return result.is_valid and result.risk_score < 0.5
        except Exception:
            return False
    
    def _normalize_sql(self, sql: str) -> str:
        """
        Normalize SQL for consistent analysis
        
        Args:
            sql: Raw SQL query
            
        Returns:
            Normalized SQL query
        """
        # Remove comments
        sql = re.sub(r'--.*?$', '', sql, flags=re.MULTILINE)
        sql = re.sub(r'/\*.*?\*/', '', sql, flags=re.DOTALL)
        
        # Convert to lowercase for analysis
        sql = sql.lower().strip()
        
        # Remove extra whitespace
        sql = re.sub(r'\s+', ' ', sql)
        
        return sql
    
    def _validate_basic_structure(self, sql: str, result: ValidationResult):
        """Validate basic SQL structure"""
        
        # Must start with SELECT
        if not sql.startswith('select'):
            result.add_error("Query must start with SELECT statement")
            result.increase_risk(1.0, "Non-SELECT statement")
            return
        
        # Check for balanced parentheses
        if sql.count('(') != sql.count(')'):
            result.add_error("Unbalanced parentheses in query")
        
        # Check for basic SQL injection patterns
        injection_patterns = [
            r';.*?(delete|drop|update|insert)',
            r'union.*?select',
            r'1\s*=\s*1',
            r'or\s+1\s*=\s*1',
            r'and\s+1\s*=\s*1'
        ]
        
        for pattern in injection_patterns:
            if re.search(pattern, sql, re.IGNORECASE):
                result.add_error(f"Potential SQL injection pattern detected: {pattern}")
                result.increase_risk(0.9, "SQL injection pattern")
    
    def _validate_security(self, sql: str, result: ValidationResult):
        """Validate security aspects of the query"""
        
        # Check for dangerous keywords
        for keyword in self.DANGEROUS_KEYWORDS:
            if keyword in sql:
                result.add_error(f"Dangerous keyword detected: {keyword}")
                result.increase_risk(1.0, f"Dangerous operation: {keyword}")
        
        # Check for risky functions
        for func in self.RISKY_FUNCTIONS:
            if func in sql:
                result.add_warning(f"Risky function detected: {func}")
                result.increase_risk(0.3, f"Risky function: {func}")
        
        # Check for multiple statements (semicolon separation)
        statements = sql.split(';')
        if len([stmt for stmt in statements if stmt.strip()]) > 1:
            result.add_error("Multiple SQL statements not allowed")
            result.increase_risk(0.8, "Multiple statements")
    
    def _validate_tables_and_views(self, sql: str, result: ValidationResult):
        """Validate table and view access"""
        
        # Extract table/view names from FROM and JOIN clauses
        table_pattern = r'(?:from|join)\s+([a-zA-Z_][a-zA-Z0-9_]*)'
        tables = re.findall(table_pattern, sql, re.IGNORECASE)
        
        for table in tables:
            table_lower = table.lower()
            if table_lower in self.APPROVED_TABLES:
                result.allowed_tables.add(table_lower)
            else:
                result.add_error(f"Access to unauthorized table/view: {table}")
                result.increase_risk(0.7, f"Unauthorized table: {table}")
        
        # Suggest using views for better performance
        if any(table in ['rspclogchain', 'rspcprocesslog'] for table in tables):
            if 'vw_latest_chain_runs' not in sql and 'vw_chain_summary' not in sql:
                result.add_suggestion("Consider using optimized views (VW_LATEST_CHAIN_RUNS, VW_CHAIN_SUMMARY) for better performance")
    
    def _validate_functions(self, sql: str, result: ValidationResult):
        """Validate SQL functions used in the query"""
        
        # Extract function calls
        function_pattern = r'([a-zA-Z_][a-zA-Z0-9_]*)\s*\('
        functions = re.findall(function_pattern, sql, re.IGNORECASE)
        
        for func in functions:
            func_lower = func.lower()
            if func_lower not in self.APPROVED_FUNCTIONS:
                result.add_warning(f"Unrecognized function: {func}")
                result.increase_risk(0.1, f"Unknown function: {func}")
    
    def _validate_performance(self, sql: str, result: ValidationResult):
        """Validate query performance aspects"""
        
        # Check for SELECT *
        if 'select *' in sql:
            result.add_warning("SELECT * can impact performance. Consider selecting specific columns.")
            result.performance_warnings.append("Avoid SELECT *")
        
        # Check for missing WHERE clause on large tables
        large_tables = ['rspclogchain', 'rspcprocesslog']
        for table in large_tables:
            if table in sql and 'where' not in sql:
                result.add_warning(f"Query on {table} without WHERE clause may be slow")
                result.performance_warnings.append(f"Missing WHERE on {table}")
        
        # Check for potential cartesian products
        join_count = sql.count('join')
        where_count = sql.count('where')
        if join_count > 1 and where_count == 0:
            result.add_warning("Multiple JOINs without WHERE clause may cause cartesian product")
            result.performance_warnings.append("Potential cartesian product")
    
    def _validate_sap_bw_specific(self, sql: str, result: ValidationResult):
        """Validate SAP BW specific query patterns"""
        
        # Check for proper status filtering
        if 'status_of_process' in sql:
            valid_statuses = ['success', 'failed', 'running', 'waiting', 'cancelled']
            for status in valid_statuses:
                if f"'{status}'" in sql or f'"{status}"' in sql:
                    break
            else:
                result.add_suggestion("Use valid status values: SUCCESS, FAILED, RUNNING, WAITING, CANCELLED")
        
        # Check for date filtering best practices
        if 'current_date' in sql:
            if 'rspclogchain' in sql and 'time' not in sql:
                result.add_suggestion("Consider including TIME column for more precise date filtering")
        
        # Check for chain ID patterns
        chain_pattern = r"chain_id\s*=\s*['\"]([^'\"]+)['\"]"
        chain_matches = re.findall(chain_pattern, sql, re.IGNORECASE)
        for chain_id in chain_matches:
            if not chain_id.upper().startswith('PC_'):
                result.add_warning(f"Chain ID '{chain_id}' doesn't follow SAP BW naming convention (PC_*)")
    
    def get_validation_summary(self, result: ValidationResult) -> Dict[str, Any]:
        """
        Get a summary of validation results
        
        Args:
            result: ValidationResult to summarize
            
        Returns:
            Dictionary with validation summary
        """
        return {
            "is_valid": result.is_valid,
            "security_level": result.security_level.value,
            "risk_score": result.risk_score,
            "error_count": len(result.errors),
            "warning_count": len(result.warnings),
            "suggestion_count": len(result.suggestions),
            "allowed_tables": list(result.allowed_tables),
            "performance_issues": len(result.performance_warnings),
            "overall_grade": self._calculate_grade(result)
        }
    
    def _calculate_grade(self, result: ValidationResult) -> str:
        """Calculate an overall grade for the query"""
        if not result.is_valid:
            return "F"
        elif result.risk_score >= 0.7:
            return "D"
        elif result.risk_score >= 0.4:
            return "C"
        elif result.warnings:
            return "B"
        else:
            return "A"

# Convenience functions
def validate_query(sql: str, 
                  security_level: SecurityLevel = SecurityLevel.STRICT,
                  context: Optional[str] = None) -> ValidationResult:
    """
    Convenience function to validate a SQL query
    
    Args:
        sql: SQL query to validate
        security_level: Security level for validation
        context: Optional context
        
    Returns:
        ValidationResult
    """
    validator = QueryValidator(security_level)
    return validator.validate_query(sql, context)

def is_query_safe(sql: str) -> bool:
    """
    Quick check if a query is safe to execute
    
    Args:
        sql: SQL query to check
        
    Returns:
        bool: True if safe, False otherwise
    """
    result = validate_query(sql, SecurityLevel.STRICT)
    return result.is_valid and result.risk_score < 0.3

# Test function
def test_query_validator():
    """Test the query validator with sample queries"""
    
    test_queries = [
        # Valid queries
        ("SELECT chain_id, status_of_process FROM vw_latest_chain_runs WHERE chain_id = 'PC_SALES_DAILY';", True),
        ("SELECT COUNT(*) FROM vw_todays_activity WHERE status_of_process = 'FAILED';", True),
        
        # Invalid queries
        ("DROP TABLE rspcchain;", False),
        ("SELECT * FROM users;", False),
        ("SELECT chain_id FROM rspcchain; DELETE FROM rspcchain;", False),
        
        # Risky queries
        ("SELECT chain_id FROM rspcchain WHERE 1=1;", False),
        ("SELECT * FROM rspclogchain;", True),  # Valid but with warnings
    ]
    
    print("Testing Query Validator")
    print("=" * 50)
    
    validator = QueryValidator(SecurityLevel.STRICT)
    
    for sql, expected_valid in test_queries:
        result = validator.validate_query(sql)
        status = "✅ PASS" if (result.is_valid == expected_valid) else "❌ FAIL"
        
        print(f"\n{status} Query: {sql[:50]}...")
        print(f"  Valid: {result.is_valid} (expected: {expected_valid})")
        print(f"  Risk Score: {result.risk_score:.2f}")
        print(f"  Grade: {validator._calculate_grade(result)}")
        
        if result.errors:
            print(f"  Errors: {result.errors[:2]}")
        if result.warnings:
            print(f"  Warnings: {result.warnings[:2]}")

if __name__ == "__main__":
    test_query_validator() 